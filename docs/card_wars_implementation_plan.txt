GAMEPLAY
- ~~player object~~
- ~~turn structure: main phase, battle phase, pass turn~~
- ~~basic card object~~
- ~~deck, discard pile, hand collections~~
- ~~deck mechanics: shuffle, draw(int), mill(int), discard(int)~~
- ~~basic triggers / effects (draw per turn)~~
- ~~basic game entity objects (creature, building, spell)~~
- ~~play card / self enters play trigger~~
- ~~action points / card cost~~
- ~~lanes, landscapes~~
- ~~decks.json~~
- ~~json-to-game-entity logic (asset manager)~~
- ~~refactor gameplay_manager and gameplay_classes~~
- ~~attack phase~~
- ~~skip first attack rule~~
- ~~create TriggerType enum, require it as param for Trigger init~~
- ~~figure out cw_lang integration~~
- ~~refactor convert existing trigger effects:~~
	- ~~per-turn draw~~
	- ~~gain/loss of actions~~
- ~~refactor game_logic: separate classes into own modules~~
- ~~implement basic Stat and IntStat and Modifier classes~~
- ~~implement placeholder quit and test options in Choice input loop~~
- ~~implement modifier application in cw_lang~~
- ~~implement conditions (add them as optional params in effect constructor)~~
- ~~create Target parent class (children: Choice, Random, Filter)~~
    - ~~replace Choice type checks with Target type checks~~
- ~~create basic logger logic (including log.txt file)~~
- ~~implement logging system in game_manager (remember to log.init())~~
- ~~implement await_input~~
- ~~refactor action handling (main phase, inspect hand, inspect card -> lot of boilerplate)~~
- ~~bug: hitting esc on inspect card brings back to index dissambiguation list~~
- ~~fix spc to pass turn~~
- ~~bug: press '?' and then 'x' or 'esc'~~
- ~~inspect card (with action labels for abilities)~~

- implement inspect lanes (with TAB to toggle between players)
- implement inspect_discard and inspect_deck (inspect_collection? incl. inspect_hand)
- implement basic logging (consider action_logic.process_user_action as log dispatcher)
- figure out user-action stack popping
- properly re-implement try_play_card (integrate with new action and ui logic)
    - probably depends on card type
    - will probably need to pop the user-action stack to return to main phase
    - for 'permanents' should probably show it in inspect lanes ui
- implement floop
- network message format and processing (local and peer)
- implement check_card_specific_requirements

INSPECT LANES

player 1		       | player 2
---------------------------------------------------------------
11 <creature>	 12 <building> | 13 <creature>	 14 <building>
21 <creature>	 22 <building> | 23 <creature>	 24 <building>
31 <creature>	 32 <building> | 33 <creature>	 34 <building>
41 <creature>	 42 <building> | 43 <creature>	 44 <building>
==============================================================
[esc] -> back
